# API Documentation

Generated by `cnote`.

## `bump_t *bump_new_with_min_align(size_t min_align);`

*Source: include/std/allocer/bump/bump.h*


在堆上创建一个新的 bump_t Arena。
* @param min_align 最小对齐。所有分配都将至少以此对齐。
必须是 2 的幂，且不大于 16。
传 1 表示默认对齐。

- **Returns**: bump_t* 成功则返回指向新 Arena 的指针，失败返回 NULL。
@note 用户必须调用 bump_free() 来释放。


---

## `bump_t *bump_new(void);`

*Source: include/std/allocer/bump/bump.h*


在堆上创建一个新的 bump_t Arena (最小对齐为 1)。


- **Returns**: bump_t* 成功则返回指向新 Arena 的指针，失败返回 NULL。
@note 用户必须调用 bump_free() 来释放。


---

## `void bump_init_with_min_align(bump_t *bump, size_t min_align);`

*Source: include/std/allocer/bump/bump.h*


初始化一个已分配的 bump_t 结构 (例如在栈上)。

- **`bump`**: 指向要初始化的 bump_t 实例的指针。
- **`min_align`**: 最小对齐。


---

## `void bump_init(bump_t *bump);`

*Source: include/std/allocer/bump/bump.h*


初始化一个已分配的 bump_t 结构 (最小对齐为 1)。
* @param bump 指向要初始化的 bump_t 实例的指针。


---

## `void bump_destroy(bump_t *bump);`

*Source: include/std/allocer/bump/bump.h*


销毁 Arena，释放其分配的所有内存块。
@note 这 *不会* 释放 bump 结构体本身。
这允许 bump_init/bump_destroy 用于栈分配的 Arena。


- **`bump`**: 要销毁的 Arena。


---

## `void bump_free(bump_t *bump);`

*Source: include/std/allocer/bump/bump.h*


销毁 Arena 并释放 bump_t 结构体本身。
@note 只能用于由 bump_new() 创建的 Arena。


- **`bump`**: 要释放的 Arena。


---

## `void bump_reset(bump_t *bump);`

*Source: include/std/allocer/bump/bump.h*


重置 Arena。

释放所有已分配的 Chunk (除了当前 Chunk)，
并将当前 Chunk 的碰撞指针重置。
之后可以重用 Arena。


- **`bump`**: 要重置的 Arena。


---

## `void *bump_alloc_layout(bump_t *bump, layout_t layout);`

*Source: include/std/allocer/bump/bump.h*


核心分配函数。

在 Arena 中分配一块具有指定布局 (大小和对齐) 的内存。
内存是 *未初始化* 的。


- **`bump`**: Arena。
- **`layout`**: 内存布局 (大小和对齐)。
- **Returns**: void* 成功则返回指向已分配内存的指针，失败 (OOM) 返回 NULL。


---

## `void *bump_alloc(bump_t *bump, size_t size, size_t align);`

*Source: include/std/allocer/bump/bump.h*


便捷函数：按大小和对齐分配。


- **`bump`**: Arena。
- **`size`**: 要分配的字节数。
- **`align`**: 内存对齐 (必须是 2 的幂)。
- **Returns**: void* 成功则返回指针，失败返回 NULL。


---

## `void *bump_alloc_layout_zeroed(bump_t *bump, layout_t layout);`

*Source: include/std/allocer/bump/bump.h*


分配一块清零的内存。


---

## `void *bump_alloc_copy(bump_t *bump, const void *src, size_t size, size_t align);`

*Source: include/std/allocer/bump/bump.h*


便捷函数：分配并复制数据。(memcpy风格)


- **`bump`**: Arena。
- **`src`**: 要复制的数据源。
- **`size`**: 要分配和复制的字节数。
- **`align`**: 内存对齐 (必须是 2 的幂)。
- **Returns**: void* 成功则返回指向 Arena 中新副本的指针，失败返回 NULL。


---

## `char *bump_alloc_str(bump_t *bump, const char *str);`

*Source: include/std/allocer/bump/bump.h*


便捷函数：分配并复制一个字符串。


- **`bump`**: Arena。
- **`str`**: 要复制的 C 字符串 (以 '\0' 结尾)。
- **Returns**: char* 成功则返回指向 Arena 中新字符串的指针，失败返回 NULL。


---

## `void *bump_realloc(bump_t *bump, void *old_ptr, size_t old_size, size_t new_size, size_t align);`

*Source: include/std/allocer/bump/bump.h*


重新分配一块内存 (分配 + 复制)。

在 arena 中，这*几乎*总是会分配一块 *新* 内存，
复制 [old_ptr, old_ptr + old_size] 的内容，
并 "泄露" (abandon) 旧的 [old_ptr] 内存块。


- **`bump`**: Arena。
- **`old_ptr`**: 指向要 "重新分配" 的旧内存块。如果为 NULL，则等同于
bump_alloc。

- **`old_size`**: *旧内存块中要复制的数据大小*。
- **`new_size`**: *要分配的新内存块的总大小*。
- **`align`**: 新内存块的对齐方式。
- **Returns**: void* 成功则返回指向*新*内存块的指针，失败返回 NULL。


---

## `void bump_set_allocation_limit(bump_t *bump, size_t limit);`

*Source: include/std/allocer/bump/bump.h*


设置分配上限 (字节)。


- **`bump`**: Arena。
- **`limit`**: 新的上限。传入 SIZE_MAX 表示无限制。


---

## `size_t bump_get_allocated_bytes(bump_t *bump);`

*Source: include/std/allocer/bump/bump.h*


获取当前已分配的 *可用* 字节总数 (所有 Chunk 的容量总和)。


- **`bump`**: Arena。
- **Returns**: size_t 字节数。


---

## `allocer_t bump_to_allocer(bump_t *bump);`

*Source: include/std/allocer/bump/glue.h*


"构造"一个 allocer_t 句柄

接受一个指向已初始化 bump_t 的指针，
并返回一个"胖指针" (allocer_t)，该指针
内部指向该 bump_t 实例和 bump vtable。


- **`bump`**: 一个指向 *已初始化* 的 bump_t 实例的指针。
- **Returns**: 一个 allocer_t 句柄。


---

## `typedef struct strhashmap strhashmap_t;`

*Source: include/std/hashmap/strhashmap.h*


(Opaque) 字符串哈希表

这是一个 "const char* -> void*" 的哈希表。
它使用开放寻址和线性探测。

- 键 (const char*) 在插入时会被 *复制* 到分配器中。
- 值 (void*) 按原样存储。
- 它不拥有 `void*` 值指向的内存。


---

## `strhashmap_t *strhashmap_new(allocer_t *alc, size_t initial_capacity);`

*Source: include/std/hashmap/strhashmap.h*


创建一个新的字符串哈希表。


- **`alc`**: 用于所有内部存储的分配器 (vtable 句柄)
- **`initial_capacity`**: 初始容量 (槽位数)。如果为 0，将使用默认值。
- **Returns**: 一个新的哈希表，或 OOM 时返回 NULL。


---

## `void strhashmap_free(strhashmap_t *map);`

*Source: include/std/hashmap/strhashmap.h*


释放哈希表及其所有内部存储。

@note 这 *不会* 释放存储在内的 `void*` 值。
它会释放哈希表为 *键* (keys) 复制的字符串。


---

## `bool strhashmap_put(strhashmap_t *map, const char *key, void *value);`

*Source: include/std/hashmap/strhashmap.h*


插入或更新一个键值对。

`key` 字符串会被*复制*到哈希表的内部存储中 (使用分配器)。
如果键已存在，旧的 `void*` 值将被替换 (不释放)。


- **`map`**: 哈希表
- **`key`**: 要插入的 C 字符串键。
- **`value`**: 要关联的 `void*` 指针。
- **Returns**: true (成功) 或 false (OOM)。


---

## `void *strhashmap_get(strhashmap_t *map, const char *key);`

*Source: include/std/hashmap/strhashmap.h*


获取一个键关联的值。

- **`map`**: 哈希表
- **`key`**: 要查找的 C 字符串键。
- **Returns**: 关联的 `void*` 指针，如果未找到则返回 NULL。
@note 如果 `NULL` 是一个有效值，请使用 `strhashmap_get_ptr`。


---

## `bool strhashmap_get_ptr(strhashmap_t *map, const char *key, void **out_value);`

*Source: include/std/hashmap/strhashmap.h*


(更安全的 Get) 检查键是否存在并获取值。


- **`map`**: 哈希表
- **`key`**: 要查找的 C 字符串键。
- **`out_value`**: [out] 如果找到，值的指针将被写入这里。
- **Returns**: true (如果找到) 或 false (如果未找到)。


---

## `bool strhashmap_delete(strhashmap_t *map, const char *key);`

*Source: include/std/hashmap/strhashmap.h*


从哈希表中删除一个键。


- **`map`**: 哈希表
- **`key`**: 要删除的 C 字符串键。
- **Returns**: true (如果删除成功) 或 false (如果未找到)。


---

## `void strhashmap_clear(strhashmap_t *map);`

*Source: include/std/hashmap/strhashmap.h*


清除哈希表中的所有条目，但不释放其容量。
* 这允许为下一次编译重用符号表，而无需重新分配。


---

## `size_t strhashmap_count(const strhashmap_t *map);`

*Source: include/std/hashmap/strhashmap.h*


获取哈希表中的条目数。


---

## `typedef struct {`

*Source: include/std/string/str_slice.h*


字符串切片 (String Slice / View)

一个非拥有 (non-owning) 的 "胖指针"，代表一个*不一定*
以 '\0' 结尾的字符串视图。

它的核心优势是 `len` 是 O(1) 的，并且它可以
"切片" (slice) 现有的内存（如源文件），而无需复制。


---

## `#define SLICE_LITERAL(s) ((str_slice_t){`

*Source: include/std/string/str_slice.h*


(辅助宏) 从 C 字符串字面量创建切片

示例: str_slice_t s = SLICE_LITERAL("hello");
(s.ptr = "hello", s.len = 5)
* sizeof("hello") == 6 (包含 \0)


---

## `static inline str_slice_t slice_from_cstr(const char *cstr) {`

*Source: include/std/string/str_slice.h*


(辅助函数) 从 C 字符串 (const char*) 创建切片
* 这是一个 O(n) 操作，因为它调用了 strlen。


---

## `static inline bool slice_equals(str_slice_t a, str_slice_t b) {`

*Source: include/std/string/str_slice.h*


(辅助函数) 比较两个切片是否相等 (O(n))


---

## `static inline bool slice_equals_cstr(str_slice_t a, const char *b_cstr) {`

*Source: include/std/string/str_slice.h*


(辅助函数) 比较切片和一个 C 字符串是否相等 (O(n))


---

## `typedef struct strintern {`

*Source: include/std/string/strintern.h*


字符串驻留器

这是一个 "string -> unique const char*" 的集合。
它接收 `str_slice_t`，并返回一个唯一的、保证
以 '\0' 结尾的 `const char*`。


---

## `bool strintern_init(strintern_t *interner, allocer_t *alc, size_t initial_capacity);`

*Source: include/std/string/strintern.h*


初始化一个字符串驻留器 (例如在栈上)。


- **`interner`**: 指向要初始化的 interner 实例的指针。
- **`alc`**: 用于所有内部存储的分配器 (vtable 句柄)。
- **Returns**: true (成功) 或 false (OOM)。


---

## `void strintern_destroy(strintern_t *interner);`

*Source: include/std/string/strintern.h*


销毁 interner 的内部数据 (entries 数组)。

@note 这 *不会* 释放 interner 结构体本身。
它*不会*释放 `alc` 分配的任何字符串。


---

## `const char *strintern_intern_slice(strintern_t *interner, str_slice_t slice);`

*Source: include/std/string/strintern.h*


驻留一个字符串切片。

检查字符串是否已被驻留。
- 如果是，返回指向*已存在*的、唯一的 `const char*` 指针。
- 如果否，使用 interner 的分配器创建*一个新的、以 '\0' 结尾*的
副本，存储它，然后返回指向该新副本的指针。


- **`interner`**: 驻留器实例。
- **`slice`**: 要驻留的切片 (不需要以 '\0' 结尾)。
- **Returns**: 唯一的、持久化的 `const char*` 指针，或 OOM 时返回 NULL。


---

## `const char *strintern_intern_cstr(strintern_t *interner, const char *str);`

*Source: include/std/string/strintern.h*


(便捷函数) 驻留一个 C 字符串。

只是 `strintern_intern_slice(interner, slice_from_cstr(str))` 的封装。


---

## `void strintern_clear(strintern_t *interner);`

*Source: include/std/string/strintern.h*


清除 interner 中的所有条目，但不释放其容量。

@note 这 *不会* 释放字符串内存 (这仍然是 `alc` 的责任)。
这用于在两次编译运行之间重置 interner，
并且*必须*与 `bump_reset(arena)` 配合使用。


---

## `size_t strintern_count(const strintern_t *interner);`

*Source: include/std/string/strintern.h*


获取 interner 中的条目数。


---

## `typedef struct string {`

*Source: include/std/string/string.h*


动态字符串构建器

一个有状态的、可变的字符串。它拥有自己的内存，
并保证*始终*以 '\0' 结尾。

(遵循 bump_t/interner_t/vec_t 模式, 在栈上初始化)


---

## `bool string_init(string_t *s, allocer_t *alc, size_t initial_capacity);`

*Source: include/std/string/string.h*


初始化一个 string (例如在栈上)。


- **`s`**: 指向要初始化的 string 实例的指针。
- **`alc`**: 用于所有内部存储的分配器 (vtable 句柄)。
- **`initial_capacity`**: *不*包含 \0 的初始容量。
- **Returns**: true (成功) 或 false (OOM)。


---

## `void string_destroy(string_t *s);`

*Source: include/std/string/string.h*


销毁 string 的内部数据 (data 数组)。


---

## `bool string_push(string_t *s, char c);`

*Source: include/std/string/string.h*


将一个字符 (char) 追加到字符串末尾。


- **`s`**: string 实例。
- **`c`**: 要追加的字符。
- **Returns**: true (成功) 或 false (OOM / 扩容失败)。


---

## `bool string_append_cstr(string_t *s, const char *cstr);`

*Source: include/std/string/string.h*


将一个 C-string (const char*) 追加到字符串末尾。


- **`s`**: string 实例。
- **`cstr`**: 要追加的 C 字符串 (以 \0 结尾)。
- **Returns**: true (成功) 或 false (OOM / 扩容失败)。


---

## `bool string_append_slice(string_t *s, str_slice_t slice);`

*Source: include/std/string/string.h*


将一个字符串切片 (str_slice_t) 追加到字符串末尾。


- **`s`**: string 实例。
- **`slice`**: 要追加的切片 (不要求 \0 结尾)。
- **Returns**: true (成功) 或 false (OOM / 扩容失败)。


---

## `void string_clear(string_t *s);`

*Source: include/std/string/string.h*


清空字符串 (count=0) 但保留容量。


---

## `const char *string_as_cstr(const string_t *s);`

*Source: include/std/string/string.h*


(O(1)) 将 string 作为 C-string (const char*) 返回。
* 保证以 \0 结尾。


---

## `str_slice_t string_as_slice(const string_t *s);`

*Source: include/std/string/string.h*


(O(1)) 将 string 作为 str_slice_t 返回。


---

## `size_t string_count(const string_t *s);`

*Source: include/std/string/string.h*


(O(1)) 获取字符串长度 (strlen)。


---

## `typedef struct idlist {`

*Source: include/std/list/idlist.h*


侵入式双向链表节点 (intrusive doubly linked list)

`prev` 指向前一个节点，`next` 指向后一个节点。
对于链表头（哨兵节点），`prev` 指向最后一个节点，`next`
指向第一个节点。 对于空链表，`prev` 和 `next`
都指向链表头自己。


---

## `static inline void idlist_init(idlist *list) {`

*Source: include/std/list/idlist.h*


初始化一个链表头 (或一个独立的节点)

- **`list`**: 要初始化的链表头


---

## `static inline void __idlist_add(idlist *prev, idlist *next, idlist *node) {`

*Source: include/std/list/idlist.h*


(内部) 在两个已知节点之间插入一个新节点

- **`prev`**: 前一个节点
- **`next`**: 后一个节点
- **`node`**: 要插入的新节点


---

## `static inline void idlist_add_tail(idlist *head, idlist *node) {`

*Source: include/std/list/idlist.h*


在链表尾部添加一个新节点 (在 head->prev 之后)

- **`head`**: 链表头
- **`node`**: 要添加的节点


---

## `static inline void idlist_add_head(idlist *head, idlist *node) {`

*Source: include/std/list/idlist.h*


在链表头部添加一个新节点 (在 head 之后)

- **`head`**: 链表头
- **`node`**: 要添加的节点


---

## `static inline void idlist_del(idlist *node) {`

*Source: include/std/list/idlist.h*


从链表中删除一个节点 (并重置该节点)

- **`node`**: 要删除的节点


---

## `static inline bool idlist_empty(const idlist *head) {`

*Source: include/std/list/idlist.h*


检查链表是否为空

- **`head`**: 链表头
- **Returns**: bool


---

## `#define idlist_for_each(head, iter_node) \ for ((iter_node) = (head)->next;`

*Source: include/std/list/idlist.h*


遍历链表 (正向)

- **`head`**: 链表头
- **`iter_node`**: 用于迭代的 idlist* 临时变量 (如 struct
idlist *node)


---

## `#define idlist_for_each_safe(head, iter_node, temp_node) \ for ((iter_node) = (head)->next, (temp_node) = (iter_node)->next;`

*Source: include/std/list/idlist.h*


遍历链表 (安全版，允许在遍历时删除节点)

- **`head`**: 链表头
- **`iter_node`**: 用于迭代的 idlist* 临时变量
- **`temp_node`**: 另一个 idlist* 临时变量，用于暂存 next
节点


---

## `bool read_file_to_slice(allocer_t *alc, const char *path, str_slice_t *out_slice);`

*Source: include/std/io/file.h*


(核心) 将整个文件读入由分配器管理的内存中。

这是编译器的主要 I/O 函数。它会分配一块大小为
(文件大小 + 1) 的内存，读入文件，并在末尾添加一个 '\0'。


- **`alc`**: 用于分配内存的分配器 (通常是一个 Arena)。
- **`path`**: 文件的路径。
- **`out_slice`**: [out] 成功时，返回一个指向新分配内存的切片。
`out_slice.ptr` 是一个以 '\0' 结尾的 C 字符串。
`out_slice.len` 是文件的 *实际* 字节大小 (不含 \0)。

- **Returns**: true (成功) 或 false (文件无法打开, 或 OOM)。


---

## `bool write_file_bytes(const char *path, const void *data, size_t len);`

*Source: include/std/io/file.h*


将一块内存写入文件。

这用于输出汇编、目标文件等。它会*覆盖*文件（如果已存在）。


- **`path`**: 文件的路径。
- **`data`**: 要写入的字节。
- **`len`**: 要写入的字节数。
- **Returns**: true (成功) 或 false (无法写入)。


---

## `typedef span_t source_span_t;`

*Source: include/std/io/sourcemap.h*


(语义别名) 在诊断上下文中, span_t 被称为 source_span_t


---

## `typedef struct source_loc {`

*Source: include/std/io/sourcemap.h*


(数据) 源码管理器查找的结果


---

## `typedef struct sourcemap {`

*Source: include/std/io/sourcemap.h*


源码管理器

`sourcemap_t` 是一个有状态的对象，它在栈上分配，
并使用 `allocer_t` 来管理其*内部*的动态内存。


---

## `bool sourcemap_init(sourcemap_t *map, allocer_t *alc);`

*Source: include/std/io/sourcemap.h*


初始化一个 sourcemap (例如在栈上)


- **`map`**: 指向要初始化的 sourcemap 实例的指针
- **`alc`**: 用于所有内部存储的分配器 (vtable 句柄)
- **Returns**: true (成功) 或 false (OOM)


---

## `void sourcemap_destroy(sourcemap_t *map);`

*Source: include/std/io/sourcemap.h*


销毁 sourcemap 的内部存储


---

## `size_t sourcemap_add_file(sourcemap_t *map, const char *filename, str_slice_t slice);`

*Source: include/std/io/sourcemap.h*


(核心) 向 sourcemap 添加一个源文件

这会扫描文件中的所有换行符 ('\n') 以构建行查找表。
它会*复制* `filename`，但*只存储* `slice` 的视图。


- **`map`**: 源码管理器
- **`filename`**: 此文件的名称 (例如 "main.nyan")。
- **`slice`**: 从 `read_file_to_slice` 获得的源文件内容。
- **Returns**: 一个 "FileID" (文件索引)，如果失败则返回 (size_t)-1


---

## `bool sourcemap_lookup(const sourcemap_t *map, size_t offset, source_loc_t *out_loc);`

*Source: include/std/io/sourcemap.h*


(核心) 将全局字节偏移量转换为 "行:列"


- **`map`**: 源码管理器
- **`offset`**: *全局*字节偏移量
- **`out_loc`**: [out] 成功时，写入结果
- **Returns**: true (成功) 或 false (偏移量越界)


---

## `static inline bool sourcemap_lookup_span(const sourcemap_t *map, source_span_t span, source_loc_t *out_loc) {`

*Source: include/std/io/sourcemap.h*


(辅助) 将一个 `source_span_t` 转换为起始位置


---

## `typedef struct bitset {`

*Source: include/std/math/bitset.h*


一个高密度位集 (在栈上初始化)


---

## `bool bitset_init(bitset_t *bs, size_t num_bits, allocer_t *alc);`

*Source: include/std/math/bitset.h*


初始化一个新的、所有位都为 0 的位集


- **`bs`**: 指向要初始化的 bitset_t 实例 (例如在栈上)
- **`num_bits`**: 集合中所需的位数
- **`alc`**: 用于分配内部 words 数组的分配器
- **Returns**: true (成功) 或 false (OOM)


---

## `bool bitset_init_all(bitset_t *bs, size_t num_bits, allocer_t *alc);`

*Source: include/std/math/bitset.h*


初始化一个新的、所有位都为 1 的位集 (全集)


---

## `void bitset_destroy(bitset_t *bs);`

*Source: include/std/math/bitset.h*


销毁位集的内部存储 (words 数组)
@note 这不会释放 bitset_t 结构体本身


---

## `size_t bitset_count(const bitset_t *bs);`

*Source: include/std/math/bitset.h*


[调试用] 统计集合中 1 的数量 (使用 Clang intrinsic，非常快)


---

## `typedef enum {`

*Source: include/std/env/args.h*


(枚举) 描述解析器返回的参数类型


---

## `ARG_TYPE_POSITIONAL } arg_type_t;`

*Source: include/std/env/args.h*

一个 "Positional" (不以 '-' 开头), e.g., "file.nyan" 

---

## `typedef struct args_parser {`

*Source: include/std/env/args.h*


(结构体) 参数解析器的状态
(在栈上初始化)


---

## `static inline void args_parser_init(args_parser_t *p, int argc, const char **argv) {`

*Source: include/std/env/args.h*


初始化一个参数解析器 (在栈上)。


- **`p`**: 指向要初始化的 args_parser_t 实例的指针。
- **`argc`**: `main` 函数的 argc。
- **`argv`**: `main` 函数的 argv。


---

## `static inline arg_type_t args_parser_peek(args_parser_t *p, str_slice_t *out_slice) {`

*Source: include/std/env/args.h*


(内部) 检查下一个参数 *而不* 消耗它。


- **`p`**: The parser.
- **`out_slice`**: [out] 用于存储参数的 `str_slice_t` 视图。
- **Returns**: The type of the argument (FLAG, POSITIONAL, or END).


---

## `static inline arg_type_t args_parser_consume(args_parser_t *p, str_slice_t *out_slice) {`

*Source: include/std/env/args.h*


消耗并返回下一个参数。


- **`p`**: The parser.
- **`out_slice`**: [out] 用于存储参数的 `str_slice_t` 视图。
- **Returns**: The type of the argument (FLAG, POSITIONAL, or END).


---

## `static inline bool args_parser_consume_value(args_parser_t *p, const char *option_name, str_slice_t *out_value) {`

*Source: include/std/env/args.h*


(便捷函数) 消耗下一个参数，并期望它是一个值。
* 用于解析 "-o <value>"


- **`p`**: The parser.
- **`option_name`**: 用于错误报告的选项名称 (e.g., "-o")
- **`out_value`**: [out] 存储值
- **Returns**: true (成功) 或 false (缺失值)


---

## `typedef struct vec {`

*Source: include/std/vec.h*


(Opaque) 指针动态数组 (Vec<void*>)

这是一个专门用于存储 `void*` 指针的动态数组。
它不拥有它所指向的内存 (释放内存是 allocer 的责任)。

(遵循 bump_t/strintern_t 模式, 在栈上初始化)


---

## `bool vec_init(vec_t *vec, allocer_t *alc, size_t initial_capacity);`

*Source: include/std/vec.h*


初始化一个 vector (例如在栈上)。


- **`vec`**: 指向要初始化的 vector 实例的指针。
- **`alc`**: 用于所有内部存储的分配器 (vtable 句柄)。
- **Returns**: true (成功) 或 false (OOM)。


---

## `void vec_destroy(vec_t *vec);`

*Source: include/std/vec.h*


销毁 vector 的内部数据 (data 数组)。

@note 这 *不会* 释放 vec 结构体本身。
它*不会*释放存储在 vector 中的 `void*` 指针。


---

## `bool vec_push(vec_t *vec, void *ptr);`

*Source: include/std/vec.h*


将一个指针追加到 vector 末尾。


- **`vec`**: vector 实例。
- **`ptr`**: 要追加的 `void*` 指针。
- **Returns**: true (成功) 或 false (OOM / 扩容失败)。


---

## `void *vec_pop(vec_t *vec);`

*Source: include/std/vec.h*


移除并返回 vector 末尾的指针。


- **`vec`**: vector 实例。
- **Returns**: 被移除的 `void*` 指针，如果 vector 为空则返回 NULL。


---

## `void *vec_get(const vec_t *vec, size_t index);`

*Source: include/std/vec.h*


获取指定索引处的指针。


- **`vec`**: vector 实例。
- **`index`**: 索引。
- **Returns**: `void*` 指针，如果索引越界则返回 NULL。


---

## `void vec_set(vec_t *vec, size_t index, void *ptr);`

*Source: include/std/vec.h*


设置指定索引处的指针。


- **`vec`**: vector 实例。
- **`index`**: 索引。
- **`ptr`**: 要设置的 `void*` 指针。
@note 如果索引越界, 将触发 `asrt` 失败。


---

## `void vec_clear(vec_t *vec);`

*Source: include/std/vec.h*


清空 vector (count=0) 但保留容量。


---

## `size_t vec_count(const vec_t *vec);`

*Source: include/std/vec.h*


获取 vector 中的元素数量。


---

## `void **vec_data(const vec_t *vec);`

*Source: include/std/vec.h*


获取指向底层 `void**` 数组的指针。
*警告*: 此指针在 `vec_push` 后可能会失效。


---

## `typedef struct layout {`

*Source: include/core/mem/layout.h*


内存请求描述符 (Memory Request Descriptor)

描述了一个内存块的大小和对齐要求。
这等同于 Rust 的 `std::alloc::Layout`。


---

## `static inline bool _is_power_of_two(size_t n) {`

*Source: include/core/mem/layout.h*


辅助函数：检查 align 是否是 2 的幂


---

## `static inline layout_t layout_from_size_align(size_t size, size_t align) {`

*Source: include/core/mem/layout.h*


从显式的大小和对齐创建一个 Layout (Rust:
`Layout::from_size_align`)


- **`size`**: 内存块的大小（字节）。
- **`align`**: 内存块的对齐（字节）。必须是 2 的幂。
- **Returns**: layout_t 描述符。
@panic 如果 align 不是 2 的幂，触发 assert。


---

## `typedef struct allocer_vtable {`

*Source: include/core/mem/allocer.h*


分配器虚函数表 (The V-Table)

定义了分配器必须实现的函数"契约"。
每个函数都接收一个 `void* self` 指针，指向具体的分配器实例
(例如 bump_t* 或 system_alloc_t*)。


---

## `void *(*alloc)(void *self, layout_t layout);`

*Source: include/core/mem/allocer.h*

分配内存。
成功时返回一个指针，OOM 时返回 NULL。


---

## `void (*free)(void *self, void *ptr, layout_t layout);`

*Source: include/core/mem/allocer.h*

释放内存。
注意：对于 Arena，这通常是一个 no-op (什么也不做)。


---

## `void *(*realloc)(void *self, void *ptr, layout_t old_layout, layout_t new_layout);`

*Source: include/core/mem/allocer.h*

重新分配内存。
成功时返回一个新指针，OOM 时返回 NULL。


---

## `void *(*zalloc)(void *self, layout_t layout);`

*Source: include/core/mem/allocer.h*

分配清零的内存。
成功时返回一个指针，OOM 时返回 NULL。


---

## `struct allocer_t {`

*Source: include/core/mem/allocer.h*


分配器句柄 (The "Fat Pointer")

这是用户持有的对象。它将"实例数据"(self)和"实现"(vtable)捆绑在一起。


---

## `static inline void *allocer_alloc(allocer_t *alc, layout_t layout) {`

*Source: include/core/mem/allocer.h*


(API) 通过 vtable 分配内存


---

## `static inline void allocer_free(allocer_t *alc, void *ptr, layout_t layout) {`

*Source: include/core/mem/allocer.h*


(API) 通过 vtable 释放内存


---

## `static inline void *allocer_realloc(allocer_t *alc, void *ptr, layout_t old_layout, layout_t new_layout) {`

*Source: include/core/mem/allocer.h*


(API) 通过 vtable 重新分配内存


---

## `static inline void *allocer_zalloc(allocer_t *alc, layout_t layout) {`

*Source: include/core/mem/allocer.h*


(API) 通过 vtable 分配清零的内存


---

## `#define asrt(cond) \ do {`

*Source: include/core/msg/asrt.h*


简单断言 (效仿 C 标准 assert)


---

## `#define asrt_msg(cond, fmt, ...) \ do {`

*Source: include/core/msg/asrt.h*


带自定义消息的断言 (使用 printf 风格)


---

## `#define dbg(fmt, ...) \ do {`

*Source: include/core/msg/dbg.h*


(API) 打印调试信息 (printf 风格)

打印 [DEBUG] [file:line] func(): <message>


---

## `typedef struct span {`

*Source: include/core/span.h*


(结构体) 表示一个半开半闭区间 [start, end)


---

## `static inline span_t range(size_t start, size_t end) {`

*Source: include/core/span.h*


(构造函数) 创建一个 span_t 结构体

@note 如果 start > end, 结果会是一个空范围 (start ==
end)。


---

## `static inline span_t span_from_len(size_t start, size_t len) {`

*Source: include/core/span.h*


(构造函数) 从 [start, start + len) 范围创建一个 span
(这个在词法分析器 (Lexer) 中非常有用)


---

## `static inline span_t span_merge(span_t a, span_t b) {`

*Source: include/core/span.h*


(辅助函数) 合并两个 span

(这个在解析器 (Parser) 中至关重要，
例如 `(a + b)` 的 span = `span_merge(a.span, b.span)`)


---

## `static inline size_t span_len(span_t span) {`

*Source: include/core/span.h*


(辅助函数) 获取 span 的长度


---

## `#define for_range(var, start, end) \ for (size_t var = (start);`

*Source: include/core/span.h*


(宏) 遍历一个字面量范围 [start, end)

@example
for_range(i, 0, 10) { // i 将从 0 到 9
dbg("i = %zu", i);
}


---

## `#define for_range_in(var, range_obj) \ for (size_t var = (range_obj).start;`

*Source: include/core/span.h*


(宏) 遍历一个 span_t 结构体

@example
span_t r = range(5, 10);
for_range_in(i, r) { // i 将从 5 到 9
dbg("i = %zu", i);
}


---

