#!/usr/bin/env python3
"""
Unicode Property Table Generator for C.
Downloads UCD files from unicode.org and generates a C header file
containing compressed range tables for binary search.
"""

import sys
import os
import urllib.request
import urllib.error
import re

# =============================================================================
# configuration
# =============================================================================

# pin the version to ensure build reproducibility.
# latest version check: https://www.unicode.org/Public/UCD/latest/ucd/
UNICODE_VERSION = "17.0.0"

BASE_URL = f"https://www.unicode.org/Public/{UNICODE_VERSION}/ucd"

# determine paths relative to this script to allow running from anywhere.
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(SCRIPT_DIR)
OUTPUT_FILE = os.path.join(PROJECT_ROOT, "src/std/unicode/tables.gen")

# list of properties to extract.
# format: (Filename, PropertyName, C_VariableName)
TARGETS = [
    ("DerivedCoreProperties.txt", "XID_Start", "XID_START_TABLE"),
    ("DerivedCoreProperties.txt", "XID_Continue", "XID_CONTINUE_TABLE"),
    ("PropList.txt", "White_Space", "WHITE_SPACE_TABLE"),
]

# =============================================================================
# core Logic
# =============================================================================

def download_file(filename):
    """Download a UCD file content with timeout handling."""
    url = f"{BASE_URL}/{filename}"
    print(f"Downloading {url}...")
    
    try:
        # set a timeout of 10 seconds
        with urllib.request.urlopen(url, timeout=10) as response:
            if response.status != 200:
                raise Exception(f"HTTP Status {response.status}")
            return response.read().decode('utf-8')
    except urllib.error.URLError as e:
        print(f"Error: Failed to download {url}.")
        print(f"Reason: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"Error: Unexpected error downloading {url}: {e}")
        sys.exit(1)

def parse_properties(content, property_name):
    """
    Parses lines like:
    0041..005A    ; XID_Start # l&  [26] LATIN CAPITAL LETTER A..
    005F          ; XID_Start # pc       LOW LINE
    """
    ranges = []
    # regex to match: Start (..End)? ; Property
    # note: We escape the property name to ensure exact match logic if needed
    pattern = r"^([0-9A-F]+)(?:\.\.([0-9A-F]+))?\s*;\s*" + re.escape(property_name)
    regex = re.compile(pattern)

    for line in content.splitlines():
        # strip comments
        if '#' in line:
            line = line.split('#')[0]
        line = line.strip()
        
        if not line:
            continue

        match = regex.match(line)
        if match:
            start = int(match.group(1), 16)
            if match.group(2):
                end = int(match.group(2), 16)
            else:
                end = start
            ranges.append((start, end))
            
    return ranges

def merge_ranges(ranges):
    """Merge adjacent or overlapping intervals to minimize table size."""
    if not ranges:
        return []

    ranges.sort()
    merged = []
    
    current_start, current_end = ranges[0]

    for i in range(1, len(ranges)):
        next_start, next_end = ranges[i]
        
        # if next range starts immediately after or within current range
        if next_start <= current_end + 1:
            current_end = max(current_end, next_end)
        else:
            merged.append((current_start, current_end))
            current_start, current_end = next_start, next_end

    merged.append((current_start, current_end))
    return merged

def generate_c_header(tables, output_path):
    """Write the generated tables to a C header file."""
    print(f"Generating {output_path}...")
    
    try:
        # ensure directory exists
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        
        with open(output_path, "w", encoding="utf-8") as f:
            f.write("/*\n")
            f.write(" * This file is auto-generated by scripts/gen_unicode.py\n")
            f.write(f" * Unicode Version: {UNICODE_VERSION}\n")
            f.write(" * DO NOT EDIT MANUALLY.\n")
            f.write(" */\n")
            f.write("#pragma once\n")
            f.write("#include <core/type.h>\n\n")
            f.write("typedef struct { u32 start; u32 end; } unicode_range_t;\n\n")

            for name, ranges in tables.items():
                f.write(f"/* Property: {name.replace('_TABLE', '')} ({len(ranges)} ranges) */\n")
                f.write(f"static const unicode_range_t {name}[] = {{\n")
                for start, end in ranges:
                    f.write(f"    {{0x{start:04X}, 0x{end:04X}}},\n")
                f.write("};\n\n")
                
    except IOError as e:
        print(f"Error writing to {output_path}: {e}")
        sys.exit(1)

def main():
    file_contents = {} # cache: filename -> content
    tables = {}        # result: C_Var_Name -> List[(start, end)]

    print(f"--- Unicode Table Generator ({UNICODE_VERSION}) ---")

    # 1. download required files (simple in-memory cache)
    for filename, _, _ in TARGETS:
        if filename not in file_contents:
            file_contents[filename] = download_file(filename)

    # 2. parse properties
    for filename, prop_name, var_name in TARGETS:
        print(f"Parsing property '{prop_name}' from {filename}...")
        raw_ranges = parse_properties(file_contents[filename], prop_name)
        merged = merge_ranges(raw_ranges)
        tables[var_name] = merged
        print(f"  -> Found {len(raw_ranges)} ranges, compressed to {len(merged)}.")

    # 3. write output
    generate_c_header(tables, OUTPUT_FILE)
    print("Done.")

if __name__ == "__main__":
    main()
