#!/usr/bin/env python3
import sys
import os
import urllib.request
import re

# === 配置 ===
UCD_BASE_URL = "https://www.unicode.org/Public/15.1.0/ucd"
# 获取脚本所在目录的绝对路径
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
# 定位到项目根目录 (假设脚本在 scripts/ 下)
PROJECT_ROOT = os.path.dirname(SCRIPT_DIR)
# 构建输出文件的绝对路径
OUTPUT_FILE = os.path.join(PROJECT_ROOT, "src/std/unicode/tables.gen")

# 我们关心的属性以及它们所在的文件
TARGETS = [
    # (Filename, PropertyName, C_VariableName)
    ("DerivedCoreProperties.txt", "XID_Start", "XID_START_TABLE"),
    ("DerivedCoreProperties.txt", "XID_Continue", "XID_CONTINUE_TABLE"),
    ("PropList.txt", "White_Space", "WHITE_SPACE_TABLE"),
]

def download_file(filename):
    url = f"{UCD_BASE_URL}/{filename}"
    print(f"Downloading {url}...")
    try:
        with urllib.request.urlopen(url) as response:
            return response.read().decode('utf-8')
    except Exception as e:
        print(f"Error downloading {url}: {e}")
        sys.exit(1)

def parse_properties(content, property_name):
    """
    解析类似这样的行:
    0041..005A    ; XID_Start # L&  [26] LATIN CAPITAL LETTER A..LATIN CAPITAL LETTER Z
    005F          ; XID_Start # Pc       LOW LINE
    """
    ranges = []
    # 匹配: Start (..End)? ; Property
    regex = re.compile(r"^([0-9A-F]+)(?:\.\.([0-9A-F]+))?\s*;\s*" + re.escape(property_name))
    
    for line in content.splitlines():
        if '#' in line:
            line = line.split('#')[0] # 去除注释
        line = line.strip()
        if not line:
            continue
            
        match = regex.match(line)
        if match:
            start = int(match.group(1), 16)
            if match.group(2):
                end = int(match.group(2), 16)
            else:
                end = start
            ranges.append((start, end))
            
    return ranges

def merge_ranges(ranges):
    """合并相邻的区间"""
    if not ranges:
        return []
    
    ranges.sort()
    merged = []
    current_start, current_end = ranges[0]
    
    for i in range(1, len(ranges)):
        next_start, next_end = ranges[i]
        if next_start <= current_end + 1:
            # 重叠或相邻，合并
            current_end = max(current_end, next_end)
        else:
            # 不连续，保存当前，开启新的
            merged.append((current_start, current_end))
            current_start, current_end = next_start, next_end
            
    merged.append((current_start, current_end))
    return merged

def generate_c_header(tables):
    with open(OUTPUT_FILE, "w") as f:
        f.write("/* This file is auto-generated by scripts/gen_unicode.py */\n")
        f.write("#pragma once\n")
        f.write("#include <core/type.h>\n\n")
        f.write("typedef struct { u32 start; u32 end; } unicode_range_t;\n\n")
        
        for name, ranges in tables.items():
            f.write(f"static const unicode_range_t {name}[] = {{\n")
            for start, end in ranges:
                f.write(f"    {{0x{start:04X}, 0x{end:04X}}},\n")
            f.write("};\n\n")

def main():
    
    file_contents = {} # filename -> content
    tables = {} # C_Var_Name -> List[(start, end)]
    
    # 1. 下载并读取
    for filename, _, _ in TARGETS:
        if filename not in file_contents:
            file_contents[filename] = download_file(filename)
            
    # 2. 解析
    for filename, prop_name, var_name in TARGETS:
        print(f"Parsing {prop_name}...")
        raw_ranges = parse_properties(file_contents[filename], prop_name)
        merged_ranges = merge_ranges(raw_ranges)
        tables[var_name] = merged_ranges
        print(f"  Found {len(raw_ranges)} ranges, merged into {len(merged_ranges)}.")

    # 3. 生成
    print(f"Generating {OUTPUT_FILE}...")
    generate_c_header(tables)
    print("Done.")

if __name__ == "__main__":
    main()
